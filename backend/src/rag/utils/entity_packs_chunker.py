"""
Entity Packs Chunker
====================

Builds canonical, field-aware entity packs (exact DB field names and values)
and a concise 5-sentence summary generated by Mistral for each entity.

Two chunk types per entity:
- canonical: strict key:value lines; no IDs in text except labeled fields
- summary: up to 5 sentences, no invention, only rephrase existing fields

Outputs vectors for a dedicated namespace (configured via advanced_db).
"""

import os
from typing import List, Dict, Any
from dotenv import load_dotenv

from ...utils.db_utils import get_connection, MODE
from ...utils.llm_mistral import llm_mistral


load_dotenv()


class EntityPacksChunker:
    def __init__(self):
        self.conn = get_connection(MODE)
        self.cur = self.conn.cursor()

    def __del__(self):
        if self.cur:
            self.cur.close()
        if self.conn:
            self.conn.close()

    def _execute_query(self, query: str) -> List[tuple]:
        self.cur.execute(query)
        return self.cur.fetchall()

    def _fetchone(self, query: str, params: tuple) -> Any:
        self.cur.execute(query, params)
        return self.cur.fetchone()

    # ------------------------ Canonical builders ------------------------
    @staticmethod
    def _canonical_block(entity_name: str, mapping: Dict[str, Any]) -> str:
        lines = [f"Entita': {entity_name}"]
        for key, value in mapping.items():
            lines.append(f"{key}: {'' if value is None else value}")
        return "\n".join(lines)

    @staticmethod
    def _summarize_canonical(entity_name: str, canonical_text: str) -> str:
        if llm_mistral is None:
            # Fallback: return first lines truncated to approximate 5 sentences
            return canonical_text.split("\n", 6)[0:6][0]
        
        from src.utils.llm_mistral import generate_answer
        context = f"Entita': {entity_name}\nDati:\n{canonical_text}"
        question = "Riassumi in massimo 5 frasi, senza inventare nulla, i dati dell'entità seguente. Mantieni solo informazioni presenti."
        
        try:
            summary = generate_answer(context, question)
            # Clean up any remaining prompt artifacts
            summary = summary.replace("[INST]", "").replace("[/INST]", "").strip()
            return summary
        except Exception as e:
            print(f"⚠️ Error generating summary for {entity_name}: {e}")
            # Fallback: return first lines truncated to approximate 5 sentences
            return canonical_text.split("\n", 6)[0:6][0]

    # --------------------------- Utente ---------------------------
    def get_utente_packs(self) -> List[Dict[str, Any]]:
        rows = self._execute_query(
            "SELECT id, email, pwd_hash, nome, cognome, email_verificata FROM Utente"
        )
        chunks: List[Dict[str, Any]] = []
        for idv, email, pwd_hash, nome, cognome, email_verificata in rows:
            data = {
                "id": idv,
                "email": email,
                "pwd_hash": pwd_hash,
                "nome": nome,
                "cognome": cognome,
                "email_verificata": email_verificata,
            }
            canonical = self._canonical_block("Utente", data)
            # canonical chunk
            chunks.append({
                "id": f"utente_{idv}__canonical",
                "text": canonical,
                "metadata": {
                    "table_name": "Utente",
                    "node_type": "user",
                    "primary_key": str(idv),
                    "chunk_kind": "canonical",
                },
            })
            # summary chunk
            summary = self._summarize_canonical("Utente", canonical)
            chunks.append({
                "id": f"utente_{idv}__summary",
                "text": summary,
                "metadata": {
                    "table_name": "Utente",
                    "node_type": "user",
                    "primary_key": str(idv),
                    "chunk_kind": "summary",
                },
            })
        return chunks

    # ------------------------ Insegnanti --------------------------
    def get_insegnanti_anagrafici_packs(self) -> List[Dict[str, Any]]:
        rows = self._execute_query(
            "SELECT id, nome, cognome, email, utente_id FROM Insegnanti_Anagrafici"
        )
        chunks: List[Dict[str, Any]] = []
        for idv, nome, cognome, email, utente_id in rows:
            data = {
                "id": idv,
                "nome": nome,
                "cognome": cognome,
                "email": email,
                "utente_id": utente_id,
            }
            canonical = self._canonical_block("Insegnanti_Anagrafici", data)
            chunks.append({
                "id": f"insegnanti_anagrafici_{idv}__canonical",
                "text": canonical,
                "metadata": {
                    "table_name": "Insegnanti_Anagrafici",
                    "node_type": "professor",
                    "primary_key": str(idv),
                    "chunk_kind": "canonical",
                },
            })
            summary = self._summarize_canonical("Insegnanti_Anagrafici", canonical)
            chunks.append({
                "id": f"insegnanti_anagrafici_{idv}__summary",
                "text": summary,
                "metadata": {
                    "table_name": "Insegnanti_Anagrafici",
                    "node_type": "professor",
                    "primary_key": str(idv),
                    "chunk_kind": "summary",
                },
            })
        return chunks

    # ------------------------ Dipartimento ------------------------
    def get_dipartimento_packs(self) -> List[Dict[str, Any]]:
        rows = self._execute_query("SELECT id, nome FROM Dipartimento")
        chunks: List[Dict[str, Any]] = []
        for idv, nome in rows:
            data = {"id": idv, "nome": nome}
            canonical = self._canonical_block("Dipartimento", data)
            chunks.append({
                "id": f"dipartimento_{idv}__canonical",
                "text": canonical,
                "metadata": {
                    "table_name": "Dipartimento",
                    "node_type": "dept",
                    "primary_key": str(idv),
                    "chunk_kind": "canonical",
                },
            })
            summary = self._summarize_canonical("Dipartimento", canonical)
            chunks.append({
                "id": f"dipartimento_{idv}__summary",
                "text": summary,
                "metadata": {
                    "table_name": "Dipartimento",
                    "node_type": "dept",
                    "primary_key": str(idv),
                    "chunk_kind": "summary",
                },
            })
        return chunks

    # --------------------------- Facolta --------------------------
    def get_facolta_packs(self) -> List[Dict[str, Any]]:
        rows = self._execute_query(
            "SELECT id, dipartimento_id, presidente, nome, contatti FROM Facolta"
        )
        chunks: List[Dict[str, Any]] = []
        for idv, dip_id, presidente, nome, contatti in rows:
            data = {
                "id": idv,
                "dipartimento_id": dip_id,
                "presidente": presidente,
                "nome": nome,
                "contatti": contatti,
            }
            # Fetch related department name (if exists)
            dept_row = self._fetchone("SELECT nome FROM Dipartimento WHERE id = %s", (dip_id,))
            rel_lines = []
            if dept_row:
                rel_lines.append(f"- Dipartimento: {dip_id} (nome: {dept_row[0]})")
            canonical = self._canonical_block("Facolta", data)
            if rel_lines:
                canonical = canonical + "\nRelazioni:\n" + "\n".join(rel_lines)
            chunks.append({
                "id": f"facolta_{idv}__canonical",
                "text": canonical,
                "metadata": {
                    "table_name": "Facolta",
                    "node_type": "faculty",
                    "primary_key": str(idv),
                    "chunk_kind": "canonical",
                },
            })
            summary = self._summarize_canonical("Facolta", canonical)
            chunks.append({
                "id": f"facolta_{idv}__summary",
                "text": summary,
                "metadata": {
                    "table_name": "Facolta",
                    "node_type": "faculty",
                    "primary_key": str(idv),
                    "chunk_kind": "summary",
                },
            })
        return chunks

    # ---------------------- Corso_di_Laurea -----------------------
    def get_corso_di_laurea_packs(self) -> List[Dict[str, Any]]:
        rows = self._execute_query(
            "SELECT id, id_facolta, nome, descrizione, classe, tipologia, mail_segreteria, domanda_laurea, test, cfu_totali FROM Corso_di_Laurea"
        )
        chunks: List[Dict[str, Any]] = []
        for row in rows:
            (
                idv,
                id_facolta,
                nome,
                descrizione,
                classe,
                tipologia,
                mail_segreteria,
                domanda_laurea,
                test,
                cfu_totali,
            ) = row
            data = {
                "id": idv,
                "id_facolta": id_facolta,
                "nome": nome,
                "descrizione": descrizione,
                "classe": classe,
                "tipologia": tipologia,
                "mail_segreteria": mail_segreteria,
                "domanda_laurea": domanda_laurea,
                "test": test,
                "cfu_totali": cfu_totali,
            }
            # Related faculty name
            fac_row = self._fetchone("SELECT nome FROM Facolta WHERE id = %s", (id_facolta,))
            rel_lines = []
            if fac_row:
                rel_lines.append(f"- Facolta: {id_facolta} (nome: {fac_row[0]})")
            canonical = self._canonical_block("Corso_di_Laurea", data)
            if rel_lines:
                canonical = canonical + "\nRelazioni:\n" + "\n".join(rel_lines)
            chunks.append({
                "id": f"corso_di_laurea_{idv}__canonical",
                "text": canonical,
                "metadata": {
                    "table_name": "Corso_di_Laurea",
                    "node_type": "degree",
                    "primary_key": str(idv),
                    "chunk_kind": "canonical",
                },
            })
            summary = self._summarize_canonical("Corso_di_Laurea", canonical)
            chunks.append({
                "id": f"corso_di_laurea_{idv}__summary",
                "text": summary,
                "metadata": {
                    "table_name": "Corso_di_Laurea",
                    "node_type": "degree",
                    "primary_key": str(idv),
                    "chunk_kind": "summary",
                },
            })
        return chunks

    # ----------------------------- Corso ---------------------------
    def get_corso_packs(self) -> List[Dict[str, Any]]:
        rows = self._execute_query(
            "SELECT id, id_corso, nome, cfu, idoneità, prerequisiti, frequenza_obbligatoria FROM Corso"
        )
        chunks: List[Dict[str, Any]] = []
        for idv, id_corso, nome, cfu, idoneita, prereq, freq in rows:
            data = {
                "id": idv,
                "id_corso": id_corso,
                "nome": nome,
                "cfu": cfu,
                "idoneità": idoneita,
                "prerequisiti": prereq,
                "frequenza_obbligatoria": freq,
            }
            # Related degree name
            deg_row = self._fetchone("SELECT nome FROM Corso_di_Laurea WHERE id = %s", (id_corso,))
            rel_lines = []
            if deg_row:
                rel_lines.append(f"- Corso_di_Laurea: {id_corso} (nome: {deg_row[0]})")
            canonical = self._canonical_block("Corso", data)
            if rel_lines:
                canonical = canonical + "\nRelazioni:\n" + "\n".join(rel_lines)
            chunks.append({
                "id": f"corso_{idv}__canonical",
                "text": canonical,
                "metadata": {
                    "table_name": "Corso",
                    "node_type": "course",
                    "primary_key": str(idv),
                    "chunk_kind": "canonical",
                },
            })
            summary = self._summarize_canonical("Corso", canonical)
            chunks.append({
                "id": f"corso_{idv}__summary",
                "text": summary,
                "metadata": {
                    "table_name": "Corso",
                    "node_type": "course",
                    "primary_key": str(idv),
                    "chunk_kind": "summary",
                },
            })
        return chunks

    # ------------------------- EdizioneCorso -----------------------
    def get_edizione_corso_packs(self) -> List[Dict[str, Any]]:
        rows = self._execute_query(
            "SELECT id, insegnante_anagrafico, data, orario, esonero, mod_Esame, stato FROM EdizioneCorso"
        )
        chunks: List[Dict[str, Any]] = []
        for idv, prof_id, data, orario, esonero, mod_esame, stato in rows:
            data_map = {
                "id": idv,
                "insegnante_anagrafico": prof_id,
                "data": data,
                "orario": orario,
                "esonero": esonero,
                "mod_Esame": mod_esame,
                "stato": stato,
            }
            # Related names: course name, professor name, platforms
            course_row = self._fetchone("SELECT nome FROM Corso WHERE id = %s", (idv,))
            prof_row = self._fetchone("SELECT nome, cognome FROM Insegnanti_Anagrafici WHERE id = %s", (prof_id,))
            self.cur.execute(
                "SELECT piattaforma_nome, codice FROM EdizioneCorso_Piattaforme WHERE edizione_id = %s AND edizione_data = %s",
                (idv, data,),
            )
            plats = self.cur.fetchall()
            rel_lines = []
            if course_row:
                rel_lines.append(f"- Corso: {idv} (nome: {course_row[0]})")
            if prof_row:
                rel_lines.append(f"- Docente: {prof_id} (nome: {prof_row[0]} {prof_row[1]})")
            for piattaforma_nome, codice in plats or []:
                rel_lines.append(f"- Piattaforma: {piattaforma_nome} (codice: {codice or ''})")
            canonical = self._canonical_block("EdizioneCorso", data_map)
            pk = f"{idv}_{data}"
            if rel_lines:
                canonical = canonical + "\nRelazioni:\n" + "\n".join(rel_lines)
            chunks.append({
                "id": f"edizione_corso_{pk}__canonical",
                "text": canonical,
                "metadata": {
                    "table_name": "EdizioneCorso",
                    "node_type": "edition",
                    "primary_key": pk,
                    "chunk_kind": "canonical",
                    "semester": data,
                },
            })
            summary = self._summarize_canonical("EdizioneCorso", canonical)
            chunks.append({
                "id": f"edizione_corso_{pk}__summary",
                "text": summary,
                "metadata": {
                    "table_name": "EdizioneCorso",
                    "node_type": "edition",
                    "primary_key": pk,
                    "chunk_kind": "summary",
                    "semester": data,
                },
            })
        return chunks

    # ------------------------- Materiale_Didattico -----------------
    def get_materiale_packs(self) -> List[Dict[str, Any]]:
        rows = self._execute_query(
            "SELECT id, utente_id, edition_id, edition_data, path_file, tipo, verificato, data_caricamento, rating_medio, numero_voti FROM Materiale_Didattico"
        )
        chunks: List[Dict[str, Any]] = []
        for row in rows:
            (
                idv,
                utente_id,
                edition_id,
                edition_data,
                path_file,
                tipo,
                verificato,
                data_caricamento,
                rating_medio,
                numero_voti,
            ) = row
            data_map = {
                "id": idv,
                "utente_id": utente_id,
                "edition_id": edition_id,
                "edition_data": edition_data,
                "path_file": path_file,
                "tipo": tipo,
                "verificato": verificato,
                "data_caricamento": data_caricamento,
                "rating_medio": rating_medio,
                "numero_voti": numero_voti,
            }
            # Relation: course name via edition_id -> Corso.id
            course_row = self._fetchone("SELECT nome FROM Corso WHERE id = %s", (edition_id,))
            rel_lines = []
            if course_row:
                rel_lines.append(f"- Corso: {edition_id} (nome: {course_row[0]})")
            canonical = self._canonical_block("Materiale_Didattico", data_map)
            if rel_lines:
                canonical = canonical + "\nRelazioni:\n" + "\n".join(rel_lines)
            chunks.append({
                "id": f"materiale_{idv}__canonical",
                "text": canonical,
                "metadata": {
                    "table_name": "Materiale_Didattico",
                    "node_type": "material",
                    "primary_key": str(idv),
                    "chunk_kind": "canonical",
                    "semester": edition_data,
                    "material_type": tipo or "",
                },
            })
            summary = self._summarize_canonical("Materiale_Didattico", canonical)
            chunks.append({
                "id": f"materiale_{idv}__summary",
                "text": summary,
                "metadata": {
                    "table_name": "Materiale_Didattico",
                    "node_type": "material",
                    "primary_key": str(idv),
                    "chunk_kind": "summary",
                    "semester": edition_data,
                    "material_type": tipo or "",
                },
            })
        return chunks

    # ------------------------------ Review -------------------------
    def get_review_packs(self) -> List[Dict[str, Any]]:
        rows = self._execute_query(
            "SELECT id, student_id, edition_id, edition_data, descrizione, voto FROM Review"
        )
        chunks: List[Dict[str, Any]] = []
        for idv, student_id, edition_id, edition_data, descrizione, voto in rows:
            data_map = {
                "id": idv,
                "student_id": student_id,
                "edition_id": edition_id,
                "edition_data": edition_data,
                "descrizione": descrizione,
                "voto": voto,
            }
            # Relation: course name via edition_id -> Corso
            course_row = self._fetchone("SELECT nome FROM Corso WHERE id = %s", (edition_id,))
            rel_lines = []
            if course_row:
                rel_lines.append(f"- Corso: {edition_id} (nome: {course_row[0]})")
            canonical = self._canonical_block("Review", data_map)
            if rel_lines:
                canonical = canonical + "\nRelazioni:\n" + "\n".join(rel_lines)
            chunks.append({
                "id": f"review_{idv}__canonical",
                "text": canonical,
                "metadata": {
                    "table_name": "Review",
                    "node_type": "review",
                    "primary_key": str(idv),
                    "chunk_kind": "canonical",
                    "semester": edition_data,
                    "rating": voto,
                },
            })
            summary = self._summarize_canonical("Review", canonical)
            chunks.append({
                "id": f"review_{idv}__summary",
                "text": summary,
                "metadata": {
                    "table_name": "Review",
                    "node_type": "review",
                    "primary_key": str(idv),
                    "chunk_kind": "summary",
                    "semester": edition_data,
                    "rating": voto,
                },
            })
        return chunks

    # ------------------------------ Tesi ---------------------------
    def get_tesi_packs(self) -> List[Dict[str, Any]]:
        rows = self._execute_query(
            "SELECT id, student_id, corso_laurea_id, titolo, file FROM Tesi"
        )
        chunks: List[Dict[str, Any]] = []
        for idv, student_id, corso_laurea_id, titolo, filev in rows:
            data_map = {
                "id": idv,
                "student_id": student_id,
                "corso_laurea_id": corso_laurea_id,
                "titolo": titolo,
                "file": filev,
            }
            # Relations: degree course name, student matricola
            degree_row = self._fetchone("SELECT nome FROM Corso_di_Laurea WHERE id = %s", (corso_laurea_id,))
            stud_row = self._fetchone("SELECT matricola FROM Studenti WHERE id = %s", (student_id,))
            rel_lines = []
            if degree_row:
                rel_lines.append(f"- Corso_di_Laurea: {corso_laurea_id} (nome: {degree_row[0]})")
            if stud_row:
                rel_lines.append(f"- Studente: {student_id} (matricola: {stud_row[0]})")
            canonical = self._canonical_block("Tesi", data_map)
            if rel_lines:
                canonical = canonical + "\nRelazioni:\n" + "\n".join(rel_lines)
            chunks.append({
                "id": f"tesi_{idv}__canonical",
                "text": canonical,
                "metadata": {
                    "table_name": "Tesi",
                    "node_type": "thesis",
                    "primary_key": str(idv),
                    "chunk_kind": "canonical",
                },
            })
            summary = self._summarize_canonical("Tesi", canonical)
            chunks.append({
                "id": f"tesi_{idv}__summary",
                "text": summary,
                "metadata": {
                    "table_name": "Tesi",
                    "node_type": "thesis",
                    "primary_key": str(idv),
                    "chunk_kind": "summary",
                },
            })
        return chunks

    # ------------------------------ Studenti ------------------------
    def get_studenti_packs(self) -> List[Dict[str, Any]]:
        rows = self._execute_query(
            "SELECT id, corso_laurea_id, matricola FROM Studenti"
        )
        chunks: List[Dict[str, Any]] = []
        for idv, corso_laurea_id, matricola in rows:
            data_map = {
                "id": idv,
                "corso_laurea_id": corso_laurea_id,
                "matricola": matricola,
            }
            # Relations: degree name, utente fields
            degree_row = self._fetchone("SELECT nome FROM Corso_di_Laurea WHERE id = %s", (corso_laurea_id,))
            user_row = self._fetchone("SELECT nome, cognome, email FROM Utente WHERE id = %s", (idv,))
            rel_lines = []
            if degree_row:
                rel_lines.append(f"- Corso_di_Laurea: {corso_laurea_id} (nome: {degree_row[0]})")
            if user_row:
                rel_lines.append(f"- Utente: {idv} (nome: {user_row[0]} {user_row[1]}, email: {user_row[2]})")
            canonical = self._canonical_block("Studenti", data_map)
            if rel_lines:
                canonical = canonical + "\nRelazioni:\n" + "\n".join(rel_lines)
            chunks.append({
                "id": f"studenti_{idv}__canonical",
                "text": canonical,
                "metadata": {
                    "table_name": "Studenti",
                    "node_type": "student",
                    "primary_key": str(idv),
                    "chunk_kind": "canonical",
                },
            })
            summary = self._summarize_canonical("Studenti", canonical)
            chunks.append({
                "id": f"studenti_{idv}__summary",
                "text": summary,
                "metadata": {
                    "table_name": "Studenti",
                    "node_type": "student",
                    "primary_key": str(idv),
                    "chunk_kind": "summary",
                },
            })
        return chunks

    # ------------------------------ API ---------------------------
    def get_all_packs(self) -> List[Dict[str, Any]]:
        chunks: List[Dict[str, Any]] = []
        try:
            chunks.extend(self.get_utente_packs())
            chunks.extend(self.get_insegnanti_anagrafici_packs())
            chunks.extend(self.get_dipartimento_packs())
            chunks.extend(self.get_facolta_packs())
            chunks.extend(self.get_corso_di_laurea_packs())
            chunks.extend(self.get_corso_packs())
            chunks.extend(self.get_edizione_corso_packs())
            chunks.extend(self.get_materiale_packs())
            chunks.extend(self.get_review_packs())
            chunks.extend(self.get_tesi_packs())
            chunks.extend(self.get_studenti_packs())
        except Exception as e:
            print(f"❌ Error generating entity packs: {e}")
        print(f"✅ Generated {len(chunks)} entity packs (canonical+summary)")
        return chunks


